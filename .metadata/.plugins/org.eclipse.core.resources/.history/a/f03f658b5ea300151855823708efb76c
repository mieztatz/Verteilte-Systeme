package DiningPhilosophersDistribute;

import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Random;

/**
 * Hochschule für angewandte Wissenschaften München
 * Verteilte Softwaresysteme - Praktikum
 * WS 2015/16
 * Aufgabe 4 Verteilte Programmierung
 * @author Diana irmscher - diana.irmscher@hm.edu
 */

public class Philosopher extends Thread {
	
	/** Wenn der Philosoph isst, sitzt er temporär an einem Platz.
	 *  Dieser Platz hat eine rechte Gabel.*/
//	private ISeat seat;
	
//	private int[] seat = null;
	
	private int seatNumber;
	private int tableNumber;
	
	/** Der Name eines Philosophen **/
	private final String name;
	
	/** Jeder Philosoph kennt den Tisch, an dem er sitzt
	 * und kann somit jederzeit seinen linken und rechten Sitznachbarn ansprechen. **/
	private final ITable table;
	
	private final IConnectionHelper connectionHelper;
	
	private ITable stubAnotherTable;
	
	private final boolean isVeryHungry;
	
	/** Anzahl der Essvorgänge, welcher ein Philospoh bereits hatte. */
	private int process;
	
	/** Diese Variable gibt an, ob der Philosoph Hunger hat oder nicht. **/
	private boolean isHungry;
	
	public Philosopher(final String name, final ITable table, final IConnectionHelper connectionHelper, final boolean isVeryHungry) {
		this.name = name;
		this.table = table;
		this.connectionHelper = connectionHelper;
		this.stubAnotherTable = null;
		this.isVeryHungry = isVeryHungry;
		
		this.process = 0;
		this.isHungry = true;
	}
	
	/** Getter für den Stub des Tisches */
	public ITable getTable() {
		return this.table;
	}
	
	public ITable getStubAnotherTable() {
		return this.stubAnotherTable;
	}
	
	public void setStubAnotherTable(final ITable stub) {
		this.stubAnotherTable = stub;
	}
	
	/** Getter und Setter der Klassenvariablen **/
	public boolean isHungry() {
		return isHungry;
	}

	public void setHungry(boolean isHungry) {
		this.isHungry = isHungry;
	}
	
	public String getPhilosopherName() {
		return this.name;
	}
	
//	public int getSeatNumber() {
//		return seatNumber;
//	}
//	
//	public void setSeatNumber(final int number) {
//		this.seatNumber = number;
//	}
//	
//	public int getTableNumber() {
//		return tableNumber;
//	}
//	
//	public void setTabelNumber(final int number) {
//		this.tableNumber = number;
//	}
	
	public int[] getSeat() {
		return new int[]{this.seatNumber, this.tableNumber};
	}
	
	public void setSeat(int seat, int table) {
		seatNumber = seat;
		tableNumber = table;
	}

	public int getProcess() {
		return process;
	}

	public void setProcess(final int process) {
		this.process = process;
	}
	
	/** LOGIK **/

	/**
	 * Meditieren und essen.
	 */
	@Override
	public void run() {
		System.out.println(this.getPhilosopherName() + " ist aktiv.");
		
		while(true) {
			/** *********** MEDITIEREN *********** **/
			if (!this.isHungry()) {
				Random r = new Random();
				double tmp = r.nextInt(100);
				if (this.isVeryHungry) {
					try {
						Thread.sleep(10);
						System.out.println(this.getPhilosopherName() + "ist sehr hungrig und meditiert nur " + 10/100 + " Sekunden.");
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				} else {
					try {
						System.out.println(this.getPhilosopherName() + " meditiert für " + tmp/1000 + " Sekunden.");
						Thread.sleep((long)tmp);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				this.setHungry(true);
			}
			/** *********** Essen *********** **/
			boolean wasSuccessful = false;
			//ersten Sitzplatz zuweisen lassen
			if (this.getSeat() == null) {
				try {
					System.out.println(this.getTable().getName());
					this.setSeat(this.getTable().getAnySeat().getNumber(), this.getTable().getNumber());
					System.out.println(this.getPhilosopherName() + " betrachtet Sitznummer " + this.getSeat()[0] + " an Tisch " + this.getSeat()[2]);
				} catch (RemoteException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			// Das ist ganz schlecht, ich merke mir nur noch die Zahlen, wo ich bin
			// das Objekt hole ich mir immer remote
//			IFork forkRight = null;
//			IFork forkLeft = null;
//			try {
//				forkRight = this.getTable().getForkOfSeat(this.getSeat()[0]);
//				forkLeft = this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]);
//			} catch (RemoteException e1) {
//				// TODO Auto-generated catch block
//				e1.printStackTrace();
//			}
			//jetzt über die einzelnen Plätze des lokalen Tisches iterieren
			try {
				for (int i = 0; i < this.getTable().getNumberOfSeats() - 1 && !wasSuccessful; i ++) {
					wasSuccessful = this.tryToGetForks();
					if (!wasSuccessful) {
						System.out.println(this.getPhilosopherName() + " konnte nicht essen und versucht es am Nachbarplatz.");
						//this.unblockFork(forkRight);
						this.setSeat(this.table.getLeftNeighbour(this.getSeat()[0]).getNumber(), this.getTable().getNumber());
						System.out.println(this.getPhilosopherName() + " betrachtet Sitznummer " + this.getSeat()[0]);
//						forkRight = this.getSeat().getForkRight();
//						forkLeft = this.table.getLeftNeighbour(this.getSeat()).getForkRight();
					}
				}
				if (!wasSuccessful) {
					//this.unblockFork(forkRight);
					System.out.println(this.getPhilosopherName() + " konnte nicht an seinem Tisch essen und versucht es am Nachbartisch.");
				}
			} catch (RemoteException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			//jetzt am ganzen Tisch versuchen, wenn noch nicht gegessen
			if (!wasSuccessful) {
				try {
					String nameAnotherTable = connectionHelper.getAnotherTable(this.getTable().getName());
					//jetzt aus der Registry den anderen Tisch holen
					Registry registry = LocateRegistry.getRegistry();
					try {
						this.setStubAnotherTable((ITable) registry.lookup(nameAnotherTable));
					} catch (NotBoundException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					System.out.println(this.getPhilosopherName() + " hat sich einen neuen Tisch gesucht mit der Nummer " + getStubAnotherTable().getNumber());
					
					//ISeat tmp = connectionHelper.getAnySeatFormAllTables();
					
					//Achtung, der Tisch kann null sein, wenn nur ein Tisch angemeldet ist
					if (this.getStubAnotherTable() != null) {
						this.setSeat(this.getStubAnotherTable().getAnySeat().getNumber(), this.getStubAnotherTable().getNumber());
						System.out.println(this.getPhilosopherName() + " betrachtet Sitznummer " + this.getSeat()[0] + " an Tisch " + this.getSeat()[1]);
					} else {
						this.setSeat(this.getTable().getAnySeat().getNumber(), this.getTable().getNumber());
						System.out.println("Es gibt keinen anderen Tisch, " + this.getPhilosopherName() + "muss es an seinem Tisch weiter versuchen.");
					}
				} catch (RemoteException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				// dem Philosophen wurde jetzt irgendein Platz zugewiesen
				// wenn er an diesem Platz nicht essen kann, stellt er sich in die Queue an
//				try {
//					forkRight = this.getSeat().getForkRight();
//					System.out.println(this.getPhilosopherName() + " hat die rechte Gabel von " + forkRight.getSeat().toString());
//					forkLeft = this.table.getLeftNeighbour(this.getSeat()).getForkRight();
//					forkLeft = this.connectionHelper.getLeftNeighbourFormAllTables(this.getSeat()).getForkRight();
//					System.out.println(this.getPhilosopherName() + " hat die linke Gabel von " + forkLeft.getSeat().toString());
//				} catch (RemoteException e) {
//					e.printStackTrace();
//				}
				wasSuccessful = this.tryToGetForks();
				if (!wasSuccessful) {
					System.out.println(this.getPhilosopherName() + " konnte nicht essen und muss auf den Platz warten.");
					// jetzt den Philosoph in die Queue einreihen
					if (this.getStubAnotherTable() != null) {
						try {
							this.getStubAnotherTable().getSeat(this.getSeat()[0]).getForkRight().addPhilosopher(this);
							System.out.println(this.getPhilosopherName() + " wartet, bis er essen kann.");
						} catch (RemoteException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					} else {
						try {
							this.getTable().getSeat(this.getSeat()[0]).getForkRight().addPhilosopher(this);
							System.out.println(this.getPhilosopherName() + " wartet, bis er essen kann.");
						} catch (RemoteException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
//					this.unblockFork(forkRight);
//					try {
//						System.err.println(this.getPhilosopherName() + " wartet, bis er essen kann.\n");
//						forkRight.addPhilosopher(this);
//					} catch (RemoteException e) {
//						e.printStackTrace();
//					}
				}
			}
		}
	}
	
	private boolean tryToGetForks() {
		boolean hasEaten = false;
		boolean hasGotForkRight = false;
		boolean hasGotForkLeft = false;
		
		try {
			//nimmt sich die rechte Gabel, wenn sie frei ist
			synchronized (this.getTable().getForkOfSeat(this.getSeat()[0])) {
				if (!this.getTable().getForkOfSeat(this.getSeat()[0]).isUsed()) {
					hasGotForkRight = this.reserveFork(this.getTable().getForkOfSeat(this.getSeat()[0]), this);
					System.out.println(this.getPhilosopherName() + " hat die rechte Gabel erfolgreich bekommen.");
				}
			}
			//wenn die rechte Gabel bekommen, dann auch die linke versuchen
			if (hasGotForkRight) {
				synchronized (this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0])) {
					if (!this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]).isUsed()) {
						hasGotForkLeft = this.reserveFork(this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]), this);
						System.out.println(this.getPhilosopherName() + " hat die linke Gabel erfolgreich bekommen.");
					}
				}
				
				if (hasGotForkLeft) {
					this.eat();
					hasEaten = true;
					//in der Methode eat() werden nach dem Essvorgang die Gabeln wieder freigegeben
				} else {
					//versuchen, die linke Gabel zu nehmen
					System.out.println(this.getPhilosopherName() + " versucht, die linke Gabel zu nehmen.");
					for (int j = 0; j < 4 && !hasEaten; j++) {
						synchronized (this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0])) {
							if (!this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]).isUsed()) {
								hasGotForkLeft = this.reserveFork(this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]), this);
								System.out.println(this.getPhilosopherName() + " hat die linke Gabel erfolgreich bekommen.");
							}	
						}
						if (hasGotForkLeft) {
							this.eat();
							hasEaten = true;
						}
						 else {
							try {
								System.out.println(this.getPhilosopherName() + " hat die linke Gabel nicht bekommen.");
								Thread.sleep(1000);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
					}
					if (!hasEaten) {
						System.out.println(this.getPhilosopherName() + " hat die linke Gabel VIERMAL nicht bekommen.");
						//wenn die linke Gabel nicht da, dann muss ich die rechte wieder freigeben
						this.unblockFork(this.getTable().getForkOfSeat(this.getSeat()[0]));
					}
				}
			} else {
				System.out.println(this.getPhilosopherName() + " hat die rechte Gabel nicht bekommen.");
			}
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return hasEaten;
	}
	
	/** In dieser Methode isst der Philosoph.
	 * Achtung: synchronized-Blöcke in reserveFork()
	 * und in unblockFork.
	 * @param forkRight
	 * @param forkLeft
	 */
	private void eat() {
		//dann kann der Philosoph essen
		//this.reserveFork(forkLeft);
		try {
			whichTabel(this.getTable().getForkOfSeat(this.getSeat()[0]), this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]));
		} catch (RemoteException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			Thread.sleep(200);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		this.setProcess(this.getProcess() + 1);
		this.setHungry(false);
		try {
			this.unblockFork(this.getTable().getForkOfSeat(this.getSeat()[0]));
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		try {
			this.unblockFork(this.getTable().getLeftNeighbourForkOfSeat(this.getSeat()[0]));
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		this.setSeat(null);
		System.out.println(this.getPhilosopherName() + " ist fertig und geht meditieren.");
		//jetzt kann der Philosoph wieder meditieren gehen
	}
	
	private void whichTabel(final IFork forkRight, final IFork forkLeft) throws RemoteException {
		int tableRight = forkRight.getSeat().getTable().getNumber();
		int tableLeft = forkLeft.getSeat().getTable().getNumber();
		String output = "";
		
		
		if(tableRight == this.table.getNumber() && tableLeft == this.table.getNumber()) {
			output += "LOKAL: ";
		} else {
			output += "REMOTE: ";
		}
		
		if (tableRight == tableLeft) {
			output += this.getPhilosopherName() + " isst an Sitzplatz " + forkRight.getSeat().getNumber() + " an Tisch " + tableRight;
		}else {
			output += this.getPhilosopherName() + " isst an Tisch " + tableRight + " mit der rechten Gabel.";
		}
		System.out.println(output);
	}

	/**
	 * Setzt den übergeben Wert.
	 * Liefert true, wenn der Wert getoggelt wurde, ansonsten false.
	 * @param forkRight
	 * @return
	 */
	private boolean unblockFork(IFork forkRight) {
		boolean result = false;
		boolean previously;
		try {
			previously = forkRight.getAndSetUsed(false, this);
			result = !(previously && forkRight.isUsed());
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}

	/**
	 * Setzt den übergeben Wert.
	 * Liefert true, wenn der Wert getoggelt wurde, ansonsten false.
	 * @param forkRight
	 * @return
	 */
	private boolean reserveFork(IFork forkRight, Philosopher philosopher) {
		boolean previously;
		boolean result = false;
		try {
			previously = forkRight.getAndSetUsed(true, philosopher);
			result = !(previously && forkRight.isUsed());
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}

}