package DiningPhilosophersDistribute;

import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class ConnectionHelper implements IConnectionHelper{
	
	private static final long serialVersionUID = -1498480465650920580L;
	
	private final List<String> listOfTables = new ArrayList<>();
	
	public ConnectionHelper() {
		
	}
	
	public boolean addTable(final String table) {
		boolean wasSuccessful = false;
		wasSuccessful = this.listOfTables.add(table);
		if (wasSuccessful) {
			System.err.println("Es wurde ein neuer Tisch mit der Nummer" + table.substring(6) + " angemeldet.");
		} else {
			System.err.println("Der Tisch konnte nicht hinzugefügt werden.");
		}
		
		if (listOfTables.size() > 1) {
			int newTable = listOfTables.indexOf(table);
			
			//dem Vorgänger sagen, dass er jetzt einen Nachbarn hat
			int priviousTable = listOfTables.indexOf(table) - 1;
			
			//dem neuen Tisch sagen, wer sein Nachfolger ist
			int followingTable = (listOfTables.indexOf(table) + 1) % listOfTables.size();
			this.connectTableHasNewNighbour(priviousTable, followingTable, newTable);
		}
		
		return wasSuccessful;
		
	}
	
	/**
	 * Gibt den Namen eines anderen Tisches zurück,
	 * wenn es mehr als einen Tisch gibt.
	 * @param table
	 * @return
	 */
	public String getAnotherTable(final String table) {
		if (listOfTables.size() == 1) {
			return null;
		} else if (listOfTables.size() == 2) {
			return listOfTables.get((listOfTables.indexOf(table) + 1) % listOfTables.size());
		} else {
			Random r = new Random();
			int tmp = r.nextInt(listOfTables.size());
			while (tmp == listOfTables.indexOf(table)) {
				tmp = r.nextInt(listOfTables.size());
			}
			return listOfTables.get(tmp - 1);
		}
	}
	
	public void connectTableHasNewNighbour(final int priviousTable, final int followingTable, final int newTable) {
		String privious = listOfTables.get(priviousTable);
		String following = listOfTables.get(followingTable);
		String newTab = listOfTables.get(newTable);
		
		
		try {
			Registry registry = LocateRegistry.getRegistry();
			ITable tablePrivious = (ITable) registry.lookup(privious);
			ITable tableFollow = (ITable) registry.lookup(following);
			ITable tabelNew = (ITable) registry.lookup(newTab);
			
			
			tablePrivious.setNeighbourTable(tabelNew);
			
			table.setNeighbourTable(table);
			//tabel sagen, dass er einen neuen nachbar hat
			// setter für nachbarn aufrufen
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

}
