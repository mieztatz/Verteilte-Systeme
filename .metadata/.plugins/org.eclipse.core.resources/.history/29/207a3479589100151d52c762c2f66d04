package DiningPhilosophers;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Hochschule für angewandte Wissenschaften München
 * Verteilte Softwaresysteme - Praktikum
 * WS 2015/16
 * Aufgabe 3.3 Parallele Programmierung - Programm "Speisende Philosophen"
 * @author Diana irmscher - diana.irmscher@hm.edu
 */

public class Fork {
	
	private AtomicBoolean isUsed = new AtomicBoolean(false);
	
	private List<Philosopher> queue = new ArrayList<>();
	
	//ist das auch über den Getter hier gelockt?
	public boolean isUsed() {
		return isUsed.get();
	}
	public void setUsed(final boolean isUsed) {
		this.isUsed.set(isUsed);
	}
	
	/**
	 * Gibt die gesamte Queue mit allen wartenden Philosophen zurück.
	 * Jede Gable verfügt über eine Queue.
	 * In dieser Queue sind alle Philosophen vermerkt,
	 * die als nächstes mit dieser Gabel essen möchten.
	 * @return List<Philosophers> - Die Liste mit allen wartenden Philosophen.
	 */
	public List<Philosopher> getQueue() {
		if (this.queue != null) {
			return this.queue;
		}
		else
			System.out.println("Es gibt keine Queue.");
		return null;
	}
	
	/**
	 * Gibt den Philosophen zurück, der als nächster essen kann.
	 * 
	 * @return Philosopher - der Philosoph, welcher als nächster essen darf
	 */
	public Philosopher getNextPhilosopher() {
		Philosopher philosopher = null;
		if (!this.queue.isEmpty()) {
			philosopher = this.queue.get(0);
		}
		return philosopher;
	}
	
	public boolean addPhilosopher(final Philosopher philosopher) {
		boolean isAdded = false;
			isAdded = this.queue.add(philosopher);
			System.out.println(philosopher.getPhilosopherName() + " hat sich in die Warteschlange eingereiht");
			try {
				System.out.println(philosopher.getPhilosopherName() + 
						" wartet, bis er als nächstes dran ist, an Position " + this.queue.indexOf(philosopher));
				System.out.println(philosopher.getPhilosopherName() + " ruft: \"Juhu, ich darf wieder essen!\"");
				// der jetzt schon hungrig?
			} catch (InterruptedException e) {
				e.printStackTrace();
		}
		return isAdded;
	}

}