package DiningPhilosophersDistribute;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class ConnectionHelper implements IConnectionHelper{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -1498480465650920580L;
	
//	private ITable[] tables = new ITable[2];
	private final List<ITable> listOfTables = new ArrayList<>();
	private ISeat[] seats;

	@Override
	public ITable getTable(int number) throws RemoteException {
		ITable table = null;
		for(ITable t : listOfTables) {
			if (t.getNumber() == number) {
				table = t;
			}
		}
		return table;
	}

	/**
	 * Meldet einen neuen Tisch an.
	 * Wenn ein neuer Tisch dazugekommen ist,
	 * muss dieser mit allen anderen verlinkt werden.
	 */
	@Override
	public void setTable(Table table) throws RemoteException {
		listOfTables.add(table);
		//tables[table.getNumber() - 1] = table;
		System.out.println("Tisch mit der Nummer " + table.getNumber() + " hat sich angemeldet.");
		
		this.seats = linkAllSeats();
	}
	
	private ISeat[] linkAllSeats() throws RemoteException {
		int numberOfAllSeats = 0;
		for(ITable t : listOfTables) {
			numberOfAllSeats += t.getNumberOfSeats();
		}
		ISeat[] seats = new ISeat[numberOfAllSeats];
		for (int i = 0; i < numberOfAllSeats; i++) {
			for (ITable t : listOfTables) {
				for (int j = 0; j < t.getSeats().length; j++) {
					seats[i] = t.getSeats()[j];
				}
			}
		}
		return seats;
	}

	@Override
	public int getNumberOfTables() throws RemoteException {
		return listOfTables.size();
		//return tables.length;
	}
	
	//brauche ich wahrscheinlich nicht mehr
	public boolean containsTable(final ITable table){
//		boolean contains = false;
//		
//		for (int i = 0; i < tables.length; i++) {
//			if (tables[i].equals(tables)) {
//				contains = true;
//			}
//		}
//		return contains;
		return listOfTables.contains(table);
	}
	
//	//brauche ich wahrscheinlich nicht mehr
//	public ITable getAnotherTabel(final int tableNumber) {
//		return tables[(tableNumber + 1) % tables.length];
//	}
	
	/**
	 * Gibt einen Platz aus von irgendeinem Tisch zurück.
	 */
	public ISeat getAnySeatFormWholeTabel() {
		Random r = new Random();
		int randomInteger = 0;
		int numberOfAllSeats = 0;
		try {
			numberOfAllSeats = numberOfSeats * connectionhelper.getNumberOfTables();
		} catch (RemoteException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		randomInteger = r.nextInt(numberOfAllSeats);
		
		ISeat[] allSeats = new ISeat[numberOfAllSeats];
		for (int i = 0; i < numberOfAllSeats;)
		
		
		return null;
	}
}
